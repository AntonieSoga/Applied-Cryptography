#!/usr/bin/env python3
# Use Python 3 for portability.
from pathlib import Path  # Import Path for simple file IO.

# Load the encrypted file as raw bytes.
enc = Path("santa_512x512.enc").read_bytes()  # Read ciphertext bytes.

# Define the known PPM header for a 512x512 P6 image with 255 max value.
header = b"P6\n512 512\n255\n"  # Known-plaintext header.

# Compute the keystream bytes by XORing ciphertext with the known header.
ks = bytes([c ^ p for c, p in zip(enc, header)])  # Recover initial keystream bytes.

# Expand the keystream bytes into LSB-first bits for matching.
ks_bits = []  # Collect keystream bits.
for b in ks:  # Iterate each keystream byte.
    for i in range(8):  # Extract 8 bits LSB-first.
        ks_bits.append((b >> i) & 1)  # Append each bit.

# LFSR feedback masks extracted from the binary.
MASK1 = 0xB8  # Mask for LFSR1.
MASK2 = 0xE8  # Mask for LFSR2.
MASK3 = 0xD2  # Mask for LFSR3.

# Define one LFSR step that returns output bit and updated state.
def lfsr_step(state, mask, size=8):  # LFSR step with width 8.
    out = state & 1  # Output bit is the LSB before shifting.
    x = state & mask  # Apply tap mask to state.
    parity = 0  # Track parity for feedback.
    while x:  # Compute parity of masked bits.
        parity ^= 1  # Flip parity for each set bit.
        x &= x - 1  # Clear the lowest set bit.
    state = (state >> 1) | (parity << (size - 1))  # Shift and insert feedback at MSB.
    return out, state  # Return output bit and new state.

# Define the nonlinear combiner function used by the binary.
def comb(a, b, c):  # Combine three LFSR output bits.
    return (a | b) if c == 0 else (a & b)  # If c==0 use OR else AND.

# Brute-force all non-zero 8-bit seeds to match the keystream bits.
def recover_seeds(bits):  # Find seeds that generate the observed bits.
    nbits = len(bits)  # Number of bits to match.
    seqs = []  # Precomputed sequences for each LFSR.
    for mask in (MASK1, MASK2, MASK3):  # For each LFSR mask.
        seq = []  # Store sequences for all seeds.
        for s in range(1, 256):  # Non-zero 8-bit seeds.
            st = s  # Current state.
            bseq = []  # Bits generated by this seed.
            for _ in range(nbits):  # Generate needed bits.
                bit, st = lfsr_step(st, mask)  # Step LFSR.
                bseq.append(bit)  # Append output bit.
            seq.append(bseq)  # Store sequence for this seed.
        seqs.append(seq)  # Store sequences for this LFSR.
    for s1 in range(1, 256):  # Try all seeds for LFSR1.
        b1 = seqs[0][s1 - 1]  # Bits for seed s1.
        for s2 in range(1, 256):  # Try all seeds for LFSR2.
            b2 = seqs[1][s2 - 1]  # Bits for seed s2.
            for s3 in range(1, 256):  # Try all seeds for LFSR3.
                b3 = seqs[2][s3 - 1]  # Bits for seed s3.
                ok = True  # Track whether all bits match.
                for i in range(nbits):  # Check each bit.
                    if comb(b1[i], b2[i], b3[i]) != bits[i]:  # Compare combiner output.
                        ok = False  # Mark mismatch.
                        break  # Stop early on mismatch.
                if ok:  # All bits matched.
                    return s1, s2, s3  # Return the matching seeds.
    raise RuntimeError("No matching seeds found")  # Fail if no seeds match.

# Recover the seeds using the known header keystream bits.
s1, s2, s3 = recover_seeds(ks_bits)  # Recover all three seeds.

# Generate a full keystream of the ciphertext length and decrypt.
keystream = bytearray()  # Build keystream bytes.
for _ in range(len(enc)):  # Generate one keystream byte per ciphertext byte.
    out = 0  # Accumulate output bits into one byte.
    for i in range(8):  # Generate 8 bits LSB-first.
        b1, s1 = lfsr_step(s1, MASK1)  # Step LFSR1.
        b2, s2 = lfsr_step(s2, MASK2)  # Step LFSR2.
        b3, s3 = lfsr_step(s3, MASK3)  # Step LFSR3.
        bit = comb(b1, b2, b3) & 1  # Combine bits into one keystream bit.
        out |= (bit << i)  # Place bit in the output byte.
    keystream.append(out)  # Append keystream byte.

# XOR the keystream with the ciphertext to recover the plaintext image.
plain = bytes([c ^ k for c, k in zip(enc, keystream)])  # Decrypt bytes.

# Write the decrypted PPM file for viewing the flag.
Path("santa_512x512.ppm").write_bytes(plain)  # Save decrypted image.
